(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{225:function(_,v,t){"use strict";t.r(v);var a=t(19),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[_._v("随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。")])]),_._v(" "),t("h2",{attrs:{id:"_5-1-用构造器确保初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-用构造器确保初始化"}},[_._v("#")]),_._v(" 5.1 用构造器确保初始化")]),_._v(" "),t("p",[_._v("构造器采用与类相同的名称，没有任何返回值。")]),_._v(" "),t("p",[_._v("创建对象时，将会为对象分配存储空间，并调用相应的构造器。不接受任何参数的构造器叫做"),t("strong",[_._v("默认构造器（无参构造器）")]),_._v("。如果创建了自己的构造器，编译器将不会允许其它方式创建对象。")]),_._v(" "),t("h2",{attrs:{id:"_5-2-方法重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-方法重载"}},[_._v("#")]),_._v(" 5.2 方法重载")]),_._v(" "),t("h3",{attrs:{id:"_5-2-1-区分重载方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-区分重载方法"}},[_._v("#")]),_._v(" 5.2.1 区分重载方法")]),_._v(" "),t("p",[_._v("每个重载的方法都必须有一个独一无二的参数列表。")]),_._v(" "),t("p",[_._v("根据方法的返回值来区分重载方法是行不通的。因为有些时候你可能会调用方法而忽略返回值。")]),_._v(" "),t("h2",{attrs:{id:"_5-3-默认构造器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-默认构造器"}},[_._v("#")]),_._v(" 5.3 默认构造器")]),_._v(" "),t("p",[_._v("如果类中没有构造器，编译器会自动创建一个默认构造器；如果你创建了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器")]),_._v(" "),t("h2",{attrs:{id:"_5-4-this-关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-this-关键字"}},[_._v("#")]),_._v(" 5.4 this 关键字")]),_._v(" "),t("p",[t("code",[_._v("this")]),_._v("关键字只能在方法内部使用，表示对“调用方法那个对象的引用”。")]),_._v(" "),t("h3",{attrs:{id:"_5-4-1-在构造器中调用构造器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-1-在构造器中调用构造器"}},[_._v("#")]),_._v(" 5.4.1 在构造器中调用构造器")]),_._v(" "),t("p",[_._v("可以使用"),t("code",[_._v("this")]),_._v("在构造器中调用构造器，但最多只能调用一个，且必须将构造器调用置于起始处。")]),_._v(" "),t("p",[_._v("除构造器外，编译器禁止在任何其它方法中调用构造器。")]),_._v(" "),t("h3",{attrs:{id:"_5-4-2-static-的含义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-2-static-的含义"}},[_._v("#")]),_._v(" 5.4.2 static 的含义")]),_._v(" "),t("p",[t("code",[_._v("static")]),_._v("方法内部不能调用"),t("strong",[_._v("非静态方法")]),_._v("，反过来可以。")]),_._v(" "),t("p",[_._v("使用"),t("code",[_._v("static")]),_._v("方法时不存在"),t("code",[_._v("this")]),_._v("。")]),_._v(" "),t("p",[_._v("可以在没有创建任何对象的前提下，通过类本身来调用"),t("code",[_._v("static")]),_._v("方法。")]),_._v(" "),t("h2",{attrs:{id:"_5-5-清理：终结处理和垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-清理：终结处理和垃圾回收"}},[_._v("#")]),_._v(" 5.5 清理：终结处理和垃圾回收")]),_._v(" "),t("p",[_._v("垃圾回收负责回收无用对象占据的内存资源，只知道释放经由"),t("code",[_._v("new")]),_._v("分配的内存。因此：")]),_._v(" "),t("ol",[t("li",[_._v("对象可能不被垃圾回收。")]),_._v(" "),t("li",[_._v("垃圾回收不等于析构。")]),_._v(" "),t("li",[_._v("垃圾回收只与内存有关。")])]),_._v(" "),t("p",[_._v("而通过其它方式为对象分配的内存却无法被垃圾回收器回收。")]),_._v(" "),t("p",[_._v("这种其它方式一般是可能在分配内存时采用了类似C语言中的做法，这种情况主要发生在使用本地方法下。本地方法是在Java中调用非Java代码的方式。在这些非Java代码中，也许会调用C的"),t("code",[_._v("malloc()")]),_._v("函数系列来分配存储空间，除非调用"),t("code",[_._v("free()")]),_._v("函数，否则存储空间无法释放。因此，需要在"),t("code",[_._v("finalize()")]),_._v("中用本地方法调用它。")]),_._v(" "),t("p",[_._v("这就是"),t("code",[_._v("finalize()")]),_._v("一般的使用场景，当然一般是用不到的。")]),_._v(" "),t("h3",{attrs:{id:"_5-5-2-你必须实施清理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-2-你必须实施清理"}},[_._v("#")]),_._v(" 5.5.2 你必须实施清理")]),_._v(" "),t("p",[_._v("垃圾回收器不能完全代替析构函数，而且绝对不能直接调用"),t("code",[_._v("finalize()")]),_._v("。如果希望进行释放存储空间之外的清理工作，还是得明确调用某个Java方法。这就等同于析构函数了，但是没有它方便。")]),_._v(" "),t("p",[_._v("记住，无论是垃圾回收还是终结，都不保证一定会发生。如果JVM并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。")]),_._v(" "),t("h3",{attrs:{id:"_5-5-3-终结条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-3-终结条件"}},[_._v("#")]),_._v(" 5.5.3 终结条件")]),_._v(" "),t("p",[t("code",[_._v("finalize()")]),_._v("只能存在于程序员很难用到的一些晦涩用法。")]),_._v(" "),t("p",[_._v("例如：可以用它来判断对象是否达到可以被回收的状态。")]),_._v(" "),t("p",[t("code",[_._v("System.gc()")]),_._v("用于强制进行终结动作。")]),_._v(" "),t("h3",{attrs:{id:"_5-5-4-垃圾回收器如何工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-4-垃圾回收器如何工作"}},[_._v("#")]),_._v(" 5.5.4 垃圾回收器如何工作")]),_._v(" "),t("p",[_._v("当创建了足够多的对象，内存资源将被耗尽时，垃圾回收器将会启动。当垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就可以很容易移动到传送带的开始处，通过垃圾回收器对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("停止-复制")]),_._v("模式。暂停程序运行，将所有存活的对象从一个堆复制到另一个堆。问题是，当没有什么垃圾产生时，也会将所有内存复制一遍。为避免这种情况，一些JVM会切换到"),t("strong",[_._v("标记-清扫")]),_._v("模式。")]),_._v(" "),t("li",[t("strong",[_._v("标记-清扫")]),_._v("模式。Sun公司早期版本的JVM使用这种做法。从堆栈和静态存储区出发，遍历所有的引用，进而找到所有存活的对象，给每个对象设一个标记。当全部标记工作完成时，开始清理，没有被标记的对象将被释放，不会发生任何复制动作。但是剩下的堆空间是不连续的。")]),_._v(" "),t("li",[t("strong",[_._v("分代")]),_._v("模式。垃圾回收器回收时往废弃的块里拷贝对象。每个块都用相应的"),t("strong",[_._v("代数")]),_._v("来记录它是否存活。如果在某处被引用，"),t("strong",[_._v("代数")]),_._v("增加。垃圾回收器定期清理时，大型对象不会被复制（代数增加），内含小型对象的那些快则被复制并整理。当对象稳定，垃圾回收器效率降低时，就会切换到"),t("strong",[_._v("标记-清扫")]),_._v("模式。")])]),_._v(" "),t("p",[_._v("这就是“自适应的，分代的，停止-复制，标记-清扫”式垃圾回收器。")]),_._v(" "),t("h2",{attrs:{id:"_5-6-成员初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-成员初始化"}},[_._v("#")]),_._v(" 5.6 成员初始化")]),_._v(" "),t("p",[_._v("类中的成员变量是基本类型，它们就会有一个默认初始值。对象引用默认为null，在实例化之前不能调用它。")]),_._v(" "),t("p",[_._v("局部变量必须要手动赋初值。")]),_._v(" "),t("h2",{attrs:{id:"_5-7-构造器初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-构造器初始化"}},[_._v("#")]),_._v(" 5.7 构造器初始化")]),_._v(" "),t("p",[_._v("自动初始化在构造器被调用之前发生。")]),_._v(" "),t("h3",{attrs:{id:"_5-7-1-初始化顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-1-初始化顺序"}},[_._v("#")]),_._v(" 5.7.1 初始化顺序")]),_._v(" "),t("p",[_._v("成员变量会首先初始化，即使变量散落在类的各处。")]),_._v(" "),t("h3",{attrs:{id:"_5-7-2-静态数据的初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-2-静态数据的初始化"}},[_._v("#")]),_._v(" 5.7.2 静态数据的初始化")]),_._v(" "),t("p",[_._v("无论创建多少个对象，静态数据都只占用一份存储区域。"),t("code",[_._v("static")]),_._v("关键字不能应用于局部变量，只能作用于域。")]),_._v(" "),t("p",[_._v("当第一次加载类时，类中的静态成员首先初始化（只会调用一次，当第二次创建类时，静态成员不会被再次初始化。）静态成员初始化后，非静态成员会初始化。然后执行构造器。")]),_._v(" "),t("p",[_._v("静态初始化只会在"),t("code",[_._v("Class")]),_._v("对象首次加载时进行一次。")]),_._v(" "),t("h3",{attrs:{id:"_5-7-3-显式的静态初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-3-显式的静态初始化"}},[_._v("#")]),_._v(" 5.7.3 显式的静态初始化")]),_._v(" "),t("p",[t("code",[_._v("static")]),_._v("静态代码块，初始化动作如同"),t("code",[_._v("static")]),_._v("成员变量，也只执行一次。")]),_._v(" "),t("h3",{attrs:{id:"_5-7-4-非静态实例初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-4-非静态实例初始化"}},[_._v("#")]),_._v(" 5.7.4 非静态实例初始化")]),_._v(" "),t("p",[_._v("非静态代码块，每次调用构造器时，都会在构造器之前执行。")])])}),[],!1,null,null,null);v.default=s.exports}}]);