(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{231:function(_,v,t){"use strict";t.r(v);var e=t(19),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[_._v("访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。")])]),_._v(" "),t("p",[_._v("如果你把一个代码段放到了某个位置，等过一会回头再看，可能会发现有更好的方法去实现。这正是重构的原动力之一，重构即重写代码，以使得它更可读，更易理解，并因此更具可维护性。")]),_._v(" "),t("p",[_._v("但是总有一些消费者（客户端程序员）需要你的代码在某些方面保持不变。你想改，他们却不想让你改。由此产生了面向对象设计中的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”。")]),_._v(" "),t("p",[_._v("这目标可以通过约定来达到。类库开发者必须同意不得删除现有方法。但是这更加棘手，类库开发者必须知道哪些数据成员被调用。")]),_._v(" "),t("p",[_._v("为了解决类库开发者重构不影响客户端调用者的现有代码的问题，Java 提供了访问权限修饰词，以指明哪些是可用的，哪些是不可用的。访问权限的等级，从大到小依次为："),t("code",[_._v("public")]),_._v("，"),t("code",[_._v("protected")]),_._v("，包访问权限（没有关键字）和 "),t("code",[_._v("private")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_6-1-包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-包"}},[_._v("#")]),_._v(" 6.1 包")]),_._v(" "),t("p",[t("code",[_._v("package")]),_._v("用于解决不同命名空间的类重名问题。")]),_._v(" "),t("p",[_._v("每一个 java 文件，只能有一个"),t("code",[_._v("public")]),_._v("类，且类名必须和文件名相同，其它不用"),t("code",[_._v("public")]),_._v("修饰的类，只能在本包内被使用。")]),_._v(" "),t("h2",{attrs:{id:"_6-2-访问权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-访问权限"}},[_._v("#")]),_._v(" 6.2 访问权限")]),_._v(" "),t("h3",{attrs:{id:"_6-2-1-包访问权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-包访问权限"}},[_._v("#")]),_._v(" 6.2.1 包访问权限")]),_._v(" "),t("p",[_._v("它是默认访问权限，没有任何权限修饰符修饰就代表它只有包访问权限，只有同一个包下可以访问。")]),_._v(" "),t("h3",{attrs:{id:"_6-2-2-public"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-public"}},[_._v("#")]),_._v(" 6.2.2 public")]),_._v(" "),t("p",[_._v("使用"),t("code",[_._v("public")]),_._v("修饰的元素对每个人都是可用的。")]),_._v(" "),t("h3",{attrs:{id:"_6-2-3-private"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-3-private"}},[_._v("#")]),_._v(" 6.2.3 private")]),_._v(" "),t("p",[_._v("任何可以肯定只是该类的一个“助手”方法的方法，都可以指定为"),t("code",[_._v("private")]),_._v("，以确保不会在包内的其他地方误用。")]),_._v(" "),t("p",[_._v("除非必须公开底层实现细目，负责就应该讲所有的域指定为"),t("code",[_._v("private")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_6-2-4-protected"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-4-protected"}},[_._v("#")]),_._v(" 6.2.4 protected")]),_._v(" "),t("p",[_._v("如果希望有某个成员的访问权限只赋予给子类，那么就需要"),t("code",[_._v("protected")]),_._v("来完成这一工作。")]),_._v(" "),t("p",[t("code",[_._v("protected")]),_._v("也提供包访问权限。")]),_._v(" "),t("h2",{attrs:{id:"_6-3-接口和实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-接口和实现"}},[_._v("#")]),_._v(" 6.3 接口和实现")]),_._v(" "),t("p",[_._v("访问权限的控制常被成为是"),t("strong",[_._v("具体实现的隐藏")]),_._v("。")]),_._v(" "),t("p",[_._v("把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是"),t("strong",[_._v("封装")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_6-4-类的访问权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-类的访问权限"}},[_._v("#")]),_._v(" 6.4 类的访问权限")]),_._v(" "),t("p",[_._v("访问权限修饰词也可以用于类上。")]),_._v(" "),t("p",[_._v("但是，类不可以是"),t("code",[_._v("private")]),_._v("的，也不可以是"),t("code",[_._v("protected")]),_._v("。所以对于类的访问权限，只有:包访问权限或"),t("code",[_._v("public")]),_._v("。")]),_._v(" "),t("p",[_._v("如果不希望其它人访问该类，可以把所有构造器指定为"),t("code",[_._v("private")]),_._v("，这样的话只有你在类的"),t("code",[_._v("static")]),_._v("成员内部可以创建。")]),_._v(" "),t("h2",{attrs:{id:"_6-5-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-总结"}},[_._v("#")]),_._v(" 6.5 总结")]),_._v(" "),t("p",[_._v("访问权限从大到小排序："),t("code",[_._v("public")]),_._v(">"),t("code",[_._v("protected")]),_._v(">包默认权限>"),t("code",[_._v("private")]),_._v("。")]),_._v(" "),t("p",[_._v("类只有"),t("code",[_._v("public")]),_._v("和包默认权限。")])])}),[],!1,null,null,null);v.default=a.exports}}]);