(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{241:function(s,a,t){"use strict";t.r(a);var _=t(19),e=Object(_.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("运行时异常信息使得你可以在程序运行时发现和使用类型信息。")])]),s._v(" "),t("p",[s._v("本章介绍 Java 如何在运行时识别对象和类的信息。主要两种方式：")]),s._v(" "),t("ul",[t("li",[s._v("RTTI，它假定我们编译时已经知道所有的类型；")]),s._v(" "),t("li",[s._v("反射，允许我们在运行时发现和使用类的信息。")])]),s._v(" "),t("h2",{attrs:{id:"_14-1-为什么需要rtti"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-为什么需要rtti"}},[s._v("#")]),s._v(" 14.1 为什么需要RTTI")]),s._v(" "),t("p",[s._v("RTTI:运行时类型检查，即在运行时，识别一个对象的类型。")]),s._v(" "),t("p",[s._v("在Java中，所有的类型转换都是在运行时进行正确性检查的。")]),s._v(" "),t("p",[s._v("在编译时，由容器和Java的泛型系统来强制确保基础引用类型；在运行时，由类型转换操作来确保具体是哪一个类型的对象。")]),s._v(" "),t("p",[s._v("多态机制，执行什么样的代码，是由引用指向的具体对象决定的。")]),s._v(" "),t("p",[s._v("代码尽可能少的了解对象的具体类型，只与对象家族的一个通用表示打交道，这样代码会更容易写，读，维护。设计也更容易实现，理解和改变。所以，“多态”是面向对象编程的基本目标。")]),s._v(" "),t("h2",{attrs:{id:"_14-2-class对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-class对象"}},[s._v("#")]),s._v(" 14.2 Class对象")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("对象用来创建类的所有“常规”对象。Java使用"),t("code",[s._v("Class")]),s._v("对象来执行其"),t("strong",[s._v("RTTI")]),s._v("。")]),s._v(" "),t("p",[s._v("每个类都有一个"),t("code",[s._v("Class")]),s._v("对象。每当编写并且编译了一个新类，就会产生一个"),t("code",[s._v("Class")]),s._v("对象（它被保存在一个同名的.class文件中）。为了生成这个类的对象，JVM将使用类加载器。")]),s._v(" "),t("p",[s._v("类加载器实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是可信类，包括Java API类，他们通常从本地磁盘上加载。这条链中不需要添加额外的类加载器。如果有特殊需求（例如以某种特殊的方式加载类），那么你有一种方式可以挂接额外的类加载器。")]),s._v(" "),t("p",[s._v("所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类，使用"),t("code",[s._v("new")]),s._v("操作符创建类的新对象也会被当做类的静态成员的引用。")]),s._v(" "),t("p",[s._v("Java程序在它开始运行之前并非被完全加载，各个部分是在必需时才加载。这与许多传统语言不同。")]),s._v(" "),t("p",[s._v("类加载器首先检查这个类的"),t("code",[s._v("Class")]),s._v("对象是否已经加载。如果未加载，默认的类加载器就会根据类型查找**.class**文件。在这个类的字节码被加载时，会接受验证确保没有损坏并不包含不良Java代码。一旦这个类的"),t("code",[s._v("Class")]),s._v("对象被载入内存，它就被用来创建这个类的所有对象。")]),s._v(" "),t("p",[t("code",[s._v("Class.forName()")]),s._v("是"),t("code",[s._v("Class")]),s._v("类的一个"),t("code",[s._v("static")]),s._v("成员。"),t("code",[s._v("Class")]),s._v("对象就和其它对象一样，我们可以获取并操作它的引用。"),t("code",[s._v("forName()")]),s._v("是取得"),t("code",[s._v("Class")]),s._v("对象的引用的一种方法。它是用一个包含目标类名的"),t("code",[s._v("String")]),s._v("作为参数，返回的是一个"),t("code",[s._v("Class")]),s._v("对象的引用。对"),t("code",[s._v("forName")]),s._v("的调用是为了产生它的副作用：如果类还没有加载就加载它。"),t("br"),s._v("\n如果"),t("code",[s._v("Class.forName()")]),s._v("找不到要加载的类，会抛出"),t("code",[s._v("ClassNotFoundException")]),s._v("。")]),s._v(" "),t("p",[s._v("如果想在运行时使用类型信息，必须首先获得对恰当的"),t("code",[s._v("Class")]),s._v("对象的引用。"),t("code",[s._v("Class.forName()")]),s._v("就是实现此功能的便捷途径。如果已经拥有了一个类型的对象，那就可以通过"),t("code",[s._v("getClass()")]),s._v("方法来获取"),t("code",[s._v("Class")]),s._v("引用了，这个方法是"),t("code",[s._v("Object")]),s._v("的一部分。"),t("br"),s._v(" "),t("code",[s._v("Class")]),s._v("包含很多有用的方法:")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("getName()")]),s._v("获取全类名。")]),s._v(" "),t("li",[t("code",[s._v("getSimpleName()")]),s._v("获取类名。")]),s._v(" "),t("li",[t("code",[s._v("getCanonicalName()")]),s._v("获取全类名。")]),s._v(" "),t("li",[t("code",[s._v("isInterface()")]),s._v("这个类是否表示某个接口。")]),s._v(" "),t("li",[t("code",[s._v("getInterfaces()")]),s._v("返回类所有接口Class的数组。")]),s._v(" "),t("li",[t("code",[s._v("getSuperclass()")]),s._v("获取类的直接父类。")]),s._v(" "),t("li",[t("code",[s._v("newInstance()")]),s._v("创建这个"),t("code",[s._v("Class")]),s._v("对象表示类的对象，但是会得到"),t("code",[s._v("Object")]),s._v("引用。另外使用"),t("code",[s._v("newInstance()")]),s._v("必须带有默认的构造器。")])]),s._v(" "),t("h3",{attrs:{id:"_14-2-1-类字面常量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-1-类字面常量"}},[s._v("#")]),s._v(" 14.2.1 类字面常量")]),s._v(" "),t("p",[s._v("Java还提供了另一种方法生成"),t("code",[s._v("Class")]),s._v("对象的引用，即使用"),t("strong",[s._v("类字面常量")]),s._v("。例如："),t("code",[s._v("FancyToy.class")]),s._v("。这样做更简单安全，因为它在编译时就会受到检查（因此不需要至于"),t("code",[s._v("try")]),s._v("语句块中），并且它根除了对"),t("code",[s._v("forName")]),s._v("方法的调用，所以也更高效。")]),s._v(" "),t("p",[s._v("类字面常量可以用于普通类，接口，数组，基本数据类型。对于基本数据类型的包装器类，还有一个标准字段"),t("strong",[s._v("TYPE")]),s._v("。"),t("strong",[s._v("TYPE")]),s._v("是一个引用，指向对应基本数据类型的"),t("code",[s._v("Class")]),s._v("对象。")]),s._v(" "),t("p",[t("strong",[s._v("注意:"),t("strong",[s._v("与"),t("code",[s._v("Class.forName")]),s._v("不同的，当使用")]),s._v(".class")]),s._v("来创建"),t("code",[s._v("Class")]),s._v("对象的引用时，不会自动初始化该"),t("code",[s._v("Class")]),s._v("对象。"),t("br"),s._v("\n为了类而做的准备工作实际包含3个步骤：")]),s._v(" "),t("ol",[t("li",[s._v("加载，这是有类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个"),t("code",[s._v("Class")]),s._v("对象。")]),s._v(" "),t("li",[s._v("链接。在链接阶段将验证字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的的其它类的所有引用。")]),s._v(" "),t("li",[s._v("初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。")])]),s._v(" "),t("p",[s._v("仅使用**.class**语法来获得对类的引用不会引发初始化。例如"),t("code",[s._v("Class initable = Initable.class")]),s._v("并不会引发初始化。")]),s._v(" "),t("p",[s._v("编译器常量不需要类的初始化就可以被读取。但是如果只是将一个域设置为"),t("code",[s._v("static final")]),s._v("还不足以确保这种行为。  如果一个"),t("code",[s._v("static")]),s._v("域不是"),t("code",[s._v("final")]),s._v("的，那么对它访问时，总是要求它被读取之前，要先进行链接和初始化。")]),s._v(" "),t("h3",{attrs:{id:"_14-2-2-泛化的class引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-2-泛化的class引用"}},[s._v("#")]),s._v(" 14.2.2 泛化的Class引用")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("引用表示的实际上它所指向的对象的确切类型，这个类型对象就是"),t("code",[s._v("Class")]),s._v("类的一个对象。")]),s._v(" "),t("p",[s._v("向"),t("code",[s._v("Class")]),s._v("引用添加泛型语法的原因仅仅是为了提供编译期类型检查。当使用了确切的泛型，"),t("code",[s._v("newInstance")]),s._v("将返回该对象的确切类型。例如：")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" ftClass "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),s._v(" fancyToy "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" ftClass"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("但是，")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" ftClass "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//Class<Toy> ftClass = ftClass.getSuperClass();不会通过编译，即使Toy")]),s._v("\n是"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),s._v("的父类，必须使用下面的声明。而且newInstance将返回"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v("引用。\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("super")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" up "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" ftClass"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getSuperClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" up"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"_14-2-3-新的转型语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-3-新的转型语法"}},[s._v("#")]),s._v(" 14.2.3 新的转型语法")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Building")]),s._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" houseType "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),s._v(" h "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" houseType"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("cast")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("这与普通的强制类型转换"),t("code",[s._v("h = (House)b;")]),s._v("好像做了很多额外的工作，我们一般不会使用它。")]),s._v(" "),t("h2",{attrs:{id:"_14-3-类型转换前先做检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-类型转换前先做检查"}},[s._v("#")]),s._v(" 14.3 类型转换前先做检查")]),s._v(" "),t("p",[s._v("使用"),t("code",[s._v("instanceof")]),s._v("来判断某一对象是否属于某个类型，避免向下转型产生"),t("code",[s._v("ClassCastException")]),s._v("。")]),s._v(" "),t("p",[s._v("在调用"),t("code",[s._v("newInstance()")]),s._v("时，可能会得到两种异常。"),t("code",[s._v("InstantiationException")]),s._v("和"),t("code",[s._v("IllegalAccessException")]),s._v("，即初始化异常和非法访问异常。非法访问异常可能是由默认构造器为"),t("code",[s._v("private")]),s._v("引起。")]),s._v(" "),t("p",[s._v("使用"),t("code",[s._v('Class.forName("")')]),s._v("加载类时，可能会产生异常，可以加"),t("code",[s._v('@SuppressWarnings("unchecked")')]),s._v("忽略警告。")]),s._v(" "),t("h3",{attrs:{id:"_14-3-2-动态的instanceof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-2-动态的instanceof"}},[s._v("#")]),s._v(" 14.3.2 动态的instanceof")]),s._v(" "),t("p",[s._v("使用 "),t("code",[s._v("Class.isInstance(obj);")]),s._v(" 来判断 obj 是否为 Class 对象的一个实例对象。")]),s._v(" "),t("h3",{attrs:{id:"_14-3-3-递归计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-3-递归计数"}},[s._v("#")]),s._v(" 14.3.3 递归计数")]),s._v(" "),t("p",[s._v("使用 "),t("code",[s._v("Class.isAssignableFrom(obj);")]),s._v(" 来判断 obj 是否为 Class 对象的一个实例对象或者它的一个子类对象。")]),s._v(" "),t("h2",{attrs:{id:"_14-5-instanceof与class的等价性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-5-instanceof与class的等价性"}},[s._v("#")]),s._v(" 14.5 instanceof与Class的等价性")]),s._v(" "),t("p",[t("code",[s._v("instanceof")]),s._v("和"),t("code",[s._v("Class.isInstance(obj)")]),s._v("的效果是一样的。用来判断某一对象是否为某一类型，它包含了继承的情况。")]),s._v(" "),t("p",[s._v("而"),t("code",[s._v("equals()")]),s._v("和"),t("code",[s._v("==")]),s._v("一样，就没有考虑继承。只判断单一的类型。")]),s._v(" "),t("h2",{attrs:{id:"_14-6-反射：运行时的类信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-6-反射：运行时的类信息"}},[s._v("#")]),s._v(" 14.6 反射：运行时的类信息")]),s._v(" "),t("p",[s._v("假设你获取了一个指向不在你的程序空间中的对象的引用；在编译时你的程序没法获知这个对象的类。例如，你从磁盘文件，或者从网络中获取了一串字节，被告知这些字节代表一个类。")]),s._v(" "),t("p",[s._v("反射提供了一种机制，用来检查可用的方法，并返回方法名。")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("类与"),t("code",[s._v("java.lang.reflect")]),s._v("类库一起对"),t("strong",[s._v("反射")]),s._v("的概念进行了支持，该类库包含了"),t("code",[s._v("Field")]),s._v(","),t("code",[s._v("Method")]),s._v("以及"),t("code",[s._v("Constructor")]),s._v("类。"),t("br"),s._v("\n这些类型的对象是JVM在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用"),t("code",[s._v("Constructor")]),s._v("创建新的对象，用"),t("code",[s._v("get()")]),s._v("和"),t("code",[s._v("set()")]),s._v("方法读取和修改与"),t("code",[s._v("Field")]),s._v("对象关联的字段，用"),t("code",[s._v("invoke()")]),s._v("方法调用与"),t("code",[s._v("Method")]),s._v("对象关联的方法。  还可以调用"),t("code",[s._v("getField()")]),s._v(","),t("code",[s._v("getMethods()")]),s._v("和"),t("code",[s._v("getConstructors()")]),s._v("等方法，以返回表示字段，方法以及构造器的对象的数组。")]),s._v(" "),t("p",[s._v("反射机制没有什么神奇之处。通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI）。用它之前，必须先加载那个类的"),t("code",[s._v("Class")]),s._v("对象。因此，那个类的**.class**文件对于JVM来说必须是可获取的：要么在本地机器上，要么通过网络获取。")]),s._v(" "),t("p",[s._v("RTTI和反射之前的区别在于：RTTI，编译器在编译时打开和检查\n"),t("strong",[s._v(".class")]),s._v("文件。而对于反射来说，"),t("strong",[s._v(".class")]),s._v("文件在编译时不可获取，在运行时打开和检查\n"),t("strong",[s._v(".class")]),s._v("文件。")]),s._v(" "),t("h3",{attrs:{id:"_14-6-1-类方法提取器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-6-1-类方法提取器"}},[s._v("#")]),s._v(" 14.6.1 类方法提取器")]),s._v(" "),t("p",[s._v("通常不需要直接使用反射工具，但是在需要创建更加动态的代码时很有用。反射在Java中是用来支持其它特性的，例如对象序列化和JavaBean。")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("的"),t("code",[s._v("getMethods()")]),s._v("和"),t("code",[s._v("getConstructors()")]),s._v("方法分别返回"),t("code",[s._v("Method")]),s._v("对象的数组和"),t("code",[s._v("Constructor")]),s._v("对象的数组。这两个类都提供了深层方法，用以解析其对象所代表的方法，并获取其名字，输入参数以及返回值。")]),s._v(" "),t("p",[t("code",[s._v("Class.forName()")]),s._v("生成的结果在编译时是不可知的，能够创建一个在编译时完全未知的对象，并调用此对象的方法。")]),s._v(" "),t("h2",{attrs:{id:"_14-7-动态代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-7-动态代理"}},[s._v("#")]),s._v(" 14.7 动态代理")]),s._v(" "),t("p",[t("strong",[s._v("代理")]),s._v("是基本的设计模式之一。它是为了提供额外的操作，而插入的用来代替实际对象的对象。这些操作通常涉及与实际对象的通信。")])])}),[],!1,null,null,null);a.default=e.exports}}]);