(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{241:function(s,a,t){"use strict";t.r(a);var e=t(19),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("运行时异常信息使得你可以在程序运行时发现和使用类型信息。")])]),s._v(" "),t("p",[s._v("本章介绍 Java 如何在运行时识别对象和类的信息。主要两种方式：")]),s._v(" "),t("ul",[t("li",[s._v("RTTI，它假定我们编译时已经知道所有的类型；")]),s._v(" "),t("li",[s._v("反射，允许我们在运行时发现和使用类的信息。")])]),s._v(" "),t("h2",{attrs:{id:"_14-1-为什么需要rtti"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-为什么需要rtti"}},[s._v("#")]),s._v(" 14.1 为什么需要RTTI")]),s._v(" "),t("p",[s._v("RTTI:运行时类型检查，即在运行时，识别一个对象的类型。")]),s._v(" "),t("p",[s._v("在Java中，所有的类型转换都是在运行时进行正确性检查的。")]),s._v(" "),t("p",[s._v("在编译时，由容器和Java的泛型系统来强制确保基础引用类型；在运行时，由类型转换操作来确保具体是哪一个类型的对象。")]),s._v(" "),t("p",[s._v("多态机制，执行什么样的代码，是由引用指向的具体对象决定的。")]),s._v(" "),t("p",[s._v("代码尽可能少的了解对象的具体类型，只与对象家族的一个通用表示打交道，这样代码会更容易写，读，维护。设计也更容易实现，理解和改变。所以，“多态”是面向对象编程的基本目标。")]),s._v(" "),t("h2",{attrs:{id:"_14-2-class对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-class对象"}},[s._v("#")]),s._v(" 14.2 Class对象")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("对象用来创建类的所有“常规”对象。Java使用"),t("code",[s._v("Class")]),s._v("对象来执行其"),t("strong",[s._v("RTTI")]),s._v("。")]),s._v(" "),t("p",[s._v("每个类都有一个"),t("code",[s._v("Class")]),s._v("对象。每当编写并且编译了一个新类，就会产生一个"),t("code",[s._v("Class")]),s._v("对象（它被保存在一个同名的.class文件中）。为了生成这个类的对象，JVM将使用类加载器。")]),s._v(" "),t("p",[s._v("类加载器实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是可信类，包括Java API类，他们通常从本地磁盘上加载。这条链中不需要添加额外的类加载器。如果有特殊需求（例如以某种特殊的方式加载类），那么你有一种方式可以挂接额外的类加载器。")]),s._v(" "),t("p",[s._v("所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类，使用"),t("code",[s._v("new")]),s._v("操作符创建类的新对象也会被当做类的静态成员的引用。")]),s._v(" "),t("p",[s._v("Java程序在它开始运行之前并非被完全加载，各个部分是在必需时才加载。这与许多传统语言不同。")]),s._v(" "),t("p",[s._v("类加载器首先检查这个类的"),t("code",[s._v("Class")]),s._v("对象是否已经加载。如果未加载，默认的类加载器就会根据类型查找**.class**文件。在这个类的字节码被加载时，会接受验证确保没有损坏并不包含不良Java代码。一旦这个类的"),t("code",[s._v("Class")]),s._v("对象被载入内存，它就被用来创建这个类的所有对象。")]),s._v(" "),t("p",[t("code",[s._v("Class.forName()")]),s._v("是"),t("code",[s._v("Class")]),s._v("类的一个"),t("code",[s._v("static")]),s._v("成员。"),t("code",[s._v("Class")]),s._v("对象就和其它对象一样，我们可以获取并操作它的引用。"),t("code",[s._v("forName()")]),s._v("是取得"),t("code",[s._v("Class")]),s._v("对象的引用的一种方法。它是用一个包含目标类名的"),t("code",[s._v("String")]),s._v("作为参数，返回的是一个"),t("code",[s._v("Class")]),s._v("对象的引用。对"),t("code",[s._v("forName")]),s._v("的调用是为了产生它的副作用：如果类还没有加载就加载它。"),t("br"),s._v("\n如果"),t("code",[s._v("Class.forName()")]),s._v("找不到要加载的类，会抛出"),t("code",[s._v("ClassNotFoundException")]),s._v("。")]),s._v(" "),t("p",[s._v("如果想在运行时使用类型信息，必须首先获得对恰当的"),t("code",[s._v("Class")]),s._v("对象的引用。"),t("code",[s._v("Class.forName()")]),s._v("就是实现此功能的便捷途径。如果已经拥有了一个类型的对象，那就可以通过"),t("code",[s._v("getClass()")]),s._v("方法来获取"),t("code",[s._v("Class")]),s._v("引用了，这个方法是"),t("code",[s._v("Object")]),s._v("的一部分。"),t("br"),s._v(" "),t("code",[s._v("Class")]),s._v("包含很多有用的方法:")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("getName()")]),s._v("获取全类名。")]),s._v(" "),t("li",[t("code",[s._v("getSimpleName()")]),s._v("获取类名。")]),s._v(" "),t("li",[t("code",[s._v("getCanonicalName()")]),s._v("获取全类名。")]),s._v(" "),t("li",[t("code",[s._v("isInterface()")]),s._v("这个类是否表示某个接口。")]),s._v(" "),t("li",[t("code",[s._v("getInterfaces()")]),s._v("返回类所有接口Class的数组。")]),s._v(" "),t("li",[t("code",[s._v("getSuperclass()")]),s._v("获取类的直接父类。")]),s._v(" "),t("li",[t("code",[s._v("newInstance()")]),s._v("创建这个"),t("code",[s._v("Class")]),s._v("对象表示类的对象，但是会得到"),t("code",[s._v("Object")]),s._v("引用。另外使用"),t("code",[s._v("newInstance()")]),s._v("必须带有默认的构造器。")])]),s._v(" "),t("h3",{attrs:{id:"_14-2-1-类字面常量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-1-类字面常量"}},[s._v("#")]),s._v(" 14.2.1 类字面常量")]),s._v(" "),t("p",[s._v("Java还提供了另一种方法生成"),t("code",[s._v("Class")]),s._v("对象的引用，即使用"),t("strong",[s._v("类字面常量")]),s._v("。例如："),t("code",[s._v("FancyToy.class")]),s._v("。这样做更简单安全，因为它在编译时就会受到检查（因此不需要至于"),t("code",[s._v("try")]),s._v("语句块中），并且它根除了对"),t("code",[s._v("forName")]),s._v("方法的调用，所以也更高效。")]),s._v(" "),t("p",[s._v("类字面常量可以用于普通类，接口，数组，基本数据类型。对于基本数据类型的包装器类，还有一个标准字段"),t("strong",[s._v("TYPE")]),s._v("。"),t("strong",[s._v("TYPE")]),s._v("是一个引用，指向对应基本数据类型的"),t("code",[s._v("Class")]),s._v("对象。")]),s._v(" "),t("p",[t("strong",[s._v("注意:"),t("strong",[s._v("与"),t("code",[s._v("Class.forName")]),s._v("不同的，当使用")]),s._v(".class")]),s._v("来创建"),t("code",[s._v("Class")]),s._v("对象的引用时，不会自动初始化该"),t("code",[s._v("Class")]),s._v("对象。"),t("br"),s._v("\n为了类而做的准备工作实际包含3个步骤：")]),s._v(" "),t("ol",[t("li",[s._v("加载，这是有类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个"),t("code",[s._v("Class")]),s._v("对象。")]),s._v(" "),t("li",[s._v("链接。在链接阶段将验证字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的的其它类的所有引用。")]),s._v(" "),t("li",[s._v("初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。")])]),s._v(" "),t("p",[s._v("仅使用**.class**语法来获得对类的引用不会引发初始化。例如"),t("code",[s._v("Class initable = Initable.class")]),s._v("并不会引发初始化。")]),s._v(" "),t("p",[s._v("编译器常量不需要类的初始化就可以被读取。但是如果只是将一个域设置为"),t("code",[s._v("static final")]),s._v("还不足以确保这种行为。  如果一个"),t("code",[s._v("static")]),s._v("域不是"),t("code",[s._v("final")]),s._v("的，那么对它访问时，总是要求它被读取之前，要先进行链接和初始化。")]),s._v(" "),t("h3",{attrs:{id:"_14-2-2-泛化的class引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-2-泛化的class引用"}},[s._v("#")]),s._v(" 14.2.2 泛化的Class引用")]),s._v(" "),t("p",[t("code",[s._v("Class")]),s._v("引用表示的实际上它所指向的对象的确切类型，这个类型对象就是"),t("code",[s._v("Class")]),s._v("类的一个对象。")]),s._v(" "),t("p",[s._v("向"),t("code",[s._v("Class")]),s._v("引用添加泛型语法的原因仅仅是为了提供编译期类型检查。当使用了确切的泛型，"),t("code",[s._v("newInstance")]),s._v("将返回该对象的确切类型。例如：")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" ftClass "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),s._v(" fancyToy "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" ftClass"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("但是，")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" ftClass "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//Class<Toy> ftClass = ftClass.getSuperClass();不会通过编译，即使Toy")]),s._v("\n是"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),s._v("的父类，必须使用下面的声明。而且newInstance将返回"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v("引用。\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("super")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FancyToy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" up "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" ftClass"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getSuperClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" up"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"_14-2-3-新的转型语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-3-新的转型语法"}},[s._v("#")]),s._v(" 14.2.3 新的转型语法")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Building")]),s._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" houseType "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("House")]),s._v(" h "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" houseType"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("cast")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("这与普通的强制类型转换"),t("code",[s._v("h = (House)b;")]),s._v("好像做了很多额外的工作，我们一般不会使用它。")])])}),[],!1,null,null,null);a.default=n.exports}}]);