(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{250:function(e,i,v){"use strict";v.r(i);var s=v(19),t=Object(s.a)({},(function(){var e=this,i=e.$createElement,v=e._self._c||i;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),v("p",[e._v("Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下：")]),e._v(" "),v("ul",[v("li",[e._v("字符串类型")]),e._v(" "),v("li",[e._v("散列类型")]),e._v(" "),v("li",[e._v("列表类型")]),e._v(" "),v("li",[e._v("集合类型")]),e._v(" "),v("li",[e._v("有序集合类型")])]),e._v(" "),v("blockquote",[v("p",[e._v("为什么要使用 Redis ?")])]),e._v(" "),v("p",[e._v("Redis 是纯内存的，数据加载和读写都比 MySQL 这种内存+硬盘要快的多。")]),e._v(" "),v("blockquote",[v("p",[e._v("Redis 也可以持久化到磁盘，为什么还要用到 MySQL ?")])]),e._v(" "),v("p",[e._v("Redis的持久化是异步的，如果服务器突然宕机，会出现丢失数据的情况，而且成本很高。而且在复杂的查询下不如 MySQL 这种关系型数据库只用 SQL 更方便高效。")]),e._v(" "),v("p",[e._v("而且，当 Redis 数据量非常大时，一旦重启，所消耗的时间是非常长的。")]),e._v(" "),v("h2",{attrs:{id:"redis-的应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-的应用场景"}},[e._v("#")]),e._v(" Redis 的应用场景")]),e._v(" "),v("ul",[v("li",[e._v("缓存（数据查询、短连接、新闻内容、商品内容等等）")]),e._v(" "),v("li",[e._v("分布式集群架构中的 session 分离")]),e._v(" "),v("li",[e._v("聊天室的在线好友列表")]),e._v(" "),v("li",[e._v("任务队列（秒杀、抢购、12306 等等）")]),e._v(" "),v("li",[e._v("应用排行榜")]),e._v(" "),v("li",[e._v("网站访问统计")]),e._v(" "),v("li",[e._v("数据过期处理（可以精确到毫秒）")])]),e._v(" "),v("h2",{attrs:{id:"redis-ha的解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-ha的解决方案"}},[e._v("#")]),e._v(" Redis HA的解决方案")]),e._v(" "),v("p",[e._v("HA(High Available，高可用性群集)机集群系统简称，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。通常把正在执 行业务的称为活动节点，而作为活动节点的一个备份的则称为备用节点。当活动节点出现问题，导致正在运行的业务（任务）不能正常运行时，备用节点此时就会侦测到，并立即接续活动节点来执行业务。从而实现业务的不中断或短暂中断。")]),e._v(" "),v("p",[e._v("Redis 一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写）该方式要实现 HA 主要有如下几种方案：")]),e._v(" "),v("ul",[v("li",[e._v("keepalived： 通过 keepalived 的虚拟 IP，提供主从的统一访问，在主出现问题时， 通过 keepalived 运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟 IP 不变)，坏处是引入 keepalived 增加部署复杂性，在有些情况下会导致数据丢失")]),e._v(" "),v("li",[e._v("zookeeper： 通过 zookeeper 来监控主从实例， 维护最新有效的 IP， 应用通过 zookeeper 取得 IP，对 Redis 进行访问，该方案需要编写大量的监控代码")]),e._v(" "),v("li",[e._v("sentinel： 通过 Sentinel 监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址( IP & PORT )是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在 Jedis2.2.2 中新增了对 Sentinel 的支持，应用通过 redis.clients.jedis.JedisSentinelPool.getResource() 取得的 Jedis 实例会及时更新到新的主实例地址")])]),e._v(" "),v("img",{attrs:{src:e.$withBase("/backend/redis/1.jpg")}}),e._v(" "),v("p",[e._v("注意： sentinel 是解决 HA 问题的，cluster 是解决主从复制问题的，不重复，并且经常一起用")]),e._v(" "),v("h2",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://www.funtl.com/zh/apache-dubbo-codeing/Redis-%E7%AE%80%E4%BB%8B.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("撸帝-Redis简介"),v("OutboundLink")],1)])])}),[],!1,null,null,null);i.default=t.exports}}]);