(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{265:function(v,_,o){"use strict";o.r(_);var l=o(19),c=Object(l.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"常用日志框架"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#常用日志框架"}},[v._v("#")]),v._v(" 常用日志框架")]),v._v(" "),o("p",[v._v("日志通常用来记录系统运行时的一些信息，如运行状况，错误信息等。\n市面上的日志框架：")]),v._v(" "),o("ul",[o("li",[o("code",[v._v("JUL")]),v._v("。日志实现，jdk中自带的日志工具。")]),v._v(" "),o("li",[o("code",[v._v("JCL")]),v._v("。日志门面，已经过时，不再用了。就是"),o("code",[v._v("commons-logging")])]),v._v(" "),o("li",[o("code",[v._v("jboss-logging")]),v._v("。日志门面，不常用。")]),v._v(" "),o("li",[o("code",[v._v("logback")]),v._v("。日志实现。"),o("code",[v._v("log4j")]),v._v("的升级版。")]),v._v(" "),o("li",[o("code",[v._v("log4j")]),v._v("。日志实现。")]),v._v(" "),o("li",[o("code",[v._v("log4j2")]),v._v("。日志实现，"),o("strong",[v._v("apache")]),v._v("下的。")]),v._v(" "),o("li",[o("code",[v._v("slf4j")]),v._v("。日志门面。")])]),v._v(" "),o("p",[v._v("slf4j,log4j,logback都是一个人开发的。log4j2属于apache下的日志框架。\n其中：")]),v._v(" "),o("ul",[o("li",[o("code",[v._v("Spring")]),v._v("框架默认使用"),o("code",[v._v("JCL")]),v._v("("),o("code",[v._v("commons-logging")]),v._v(")")]),v._v(" "),o("li",[o("code",[v._v("SpringBoot2")]),v._v("默认使用"),o("code",[v._v("slf4j")]),v._v("和"),o("code",[v._v("logback")]),v._v("。")])]),v._v(" "),o("h2",{attrs:{id:"如何使用slf4j"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何使用slf4j"}},[v._v("#")]),v._v(" 如何使用slf4j")]),v._v(" "),o("p",[v._v("开发时，不应该直接使用日志实现类，而是调用日志抽象层。目前大多选用"),o("code",[v._v("slf4j")]),v._v("作为日志门面，应当导入"),o("code",[v._v("slf4j-api.jar")]),v._v("。")]),v._v(" "),o("ul",[o("li",[o("code",[v._v("logback")]),v._v("。导入"),o("code",[v._v("logback-classic.jar")]),v._v("和"),o("code",[v._v("logback-core.jar")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("log4j")]),v._v("。由于"),o("code",[v._v("log4j")]),v._v("出现的较早，当时还未提出日志门面的概念，因此若要使用"),o("code",[v._v("log4j")]),v._v("和"),o("code",[v._v("slf4j")]),v._v("。除了需要导入"),o("code",[v._v("log4j.jar")]),v._v("，还需要导入一个适配层"),o("code",[v._v("slf4j-log412.jar")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("JUL")]),v._v("。同"),o("code",[v._v("log4j")]),v._v("，也需要导入一个适配层"),o("code",[v._v("slf4j-jdk14.jar")]),v._v("。")])]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("配置文件还是使用所选日志框架本身的日志文件配置。")])]),v._v(" "),o("h2",{attrs:{id:"遗留问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#遗留问题"}},[v._v("#")]),v._v(" 遗留问题")]),v._v(" "),o("p",[v._v("项目中所使用的框架几乎都集成了自己的日志框架。因此会造成日志框架太多无法选择。这时会采用一些适配层包来进行转换。")]),v._v(" "),o("ul",[o("li",[o("code",[v._v("jcl-over-slf4j.jar")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("log4j-over-slf4j.jar")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("jul-to-slf4j.jar")]),v._v("。")])]),v._v(" "),o("p",[v._v("例如，如果你想要使用"),o("code",[v._v("logback")]),v._v("，但是引入的其它依赖中又依赖了"),o("code",[v._v("log4j")]),v._v("，这时候的解决方法就是:"),o("strong",[v._v("排除依赖中的"),o("code",[v._v("log4j")]),v._v("，并用相应的包，如"),o("code",[v._v("log4j-over-slf4j")]),v._v("来替换。")])]),v._v(" "),o("p",[o("code",[v._v("SpringBoot")]),v._v("便是使用了这种方式，因此当我们引入其它依赖时，如果依赖中存在"),o("code",[v._v("log4j")]),v._v("等日志实现框架，就会产生冲突，因为"),o("code",[v._v("log4j-over-slf4j")]),v._v("的实现方法是使用包命覆盖的方法，如果再引入"),o("code",[v._v("log4j")]),v._v("，就等于存在两个相同的包和类，这时我们只需要将它排除即可。因为"),o("code",[v._v("SpringBoot")]),v._v("已经引入了大多数适配包。")])])}),[],!1,null,null,null);_.default=c.exports}}]);