---
autoGroup-1: Java 编程思想
title: 第13章 字符串
---

## 13.1 不可变String
`String`对象是不可变的。即使我们将其引用指向了另一个`String`对象。但是原来的对象本身还在内存中。

查看源码中可以看到，`String`类中的方法，例如`replace`，都是创建了一个新的`char[]`来依次比较并替换后`new`了一个新的`String`对象返回，而不是改变`value[]`本身。这是因为`String`类中用来存储字符串的`value[]`是`final`，不能被改变。所以`String`对象是不可变的。

## 13.2 重载“+”与StringBuilder
`String`对象是不可变的。`String`对象具有只读特性，指向它的任何引用都不能改变它的值。

这种不可变性带来一定的效率问题。"+"和"+="是 Java 中仅有的两个重载过的操作符，Java不允许程序员重载任何操作符。

使用“+”可以用来连接`String`。通常情况下，如果我们使用"+"，编译器在编译时会自动帮我们优化（使用`StringBuilder.append()`），但是在循环的情况下，编译器每次循环都会帮我们创建一个`StringBuilder`对象，这就是使用"+"或“+=”连接字符串所带来的效率问题。

当然通常简单的进行一次字符串连接，我们只需要简单的使用"+"就可以，编译器可以自动完成优化。

## 13.3 无意识的递归
这是什么意思呢？

我们知道所有的容器类都为我们已经重写了`toString()`方法。例如`ArrayList.toString()`，它会遍历`ArrayList`中的所有元素，并调用它们的`toString()`方法，拼接在一起。

但是如果我想用`toString()`打印出对象的内存地址，我们通常考虑`this`关键字。

这就导致了一个问题。

`String`后的"+"都会被认为是字符串拼接符号，它后面的所有元素都会被转换成`String`，当`this`需要被转换成`String`时，它又调用了`toString()`方法。这就产生了**递归调用**错误。


## 13.4 String的常用方法
当需要改变字符串的内容时，`String`类的方法都会返回一个新的`String`对象。如果内容没有发生改变，`String`的方法只是返回指向原对象的引用而已。这可以节约存储空间以及避免额外的开销。

## 13.5 格式化输出

### 13.5.2 System.out.format()
`System.out.format()`类似于 C 语言中的`printf()`，它就是模仿 C 的。与 C 一样。例如：`System.out.format("%d,%f",x,y);`，`%d`和`%f`都表示一个占位符，分别为整数和浮点数。

### 13.5.3 Formatter类
Java中，所有的格式化功能都由`java.util.Formatter类处理`。可以将`Formatter`看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创建一个`Formatter`对象的时候，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出。

### 13.5.4 格式化说明符
可以在输出时控制宽度。例如：
```java
Formatter f = new Formatter(System.out);
f.format("%-15s %5s %10s\n","商品","数量","价格");
f.format("%-15.15s %5d %10.2f\n","可口可乐","1","3.00");
```
`%-15s`表示15个字符宽度，`%10.2f`表示精确10个字符宽度并精确2位小数。