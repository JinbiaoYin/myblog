---
autoGroup-1: Java 编程思想
title: 第14章 类型信息
---

> 运行时异常信息使得你可以在程序运行时发现和使用类型信息。

本章介绍 Java 如何在运行时识别对象和类的信息。主要两种方式：
- RTTI，它假定我们编译时已经知道所有的类型；
- 反射，允许我们在运行时发现和使用类的信息。

## 14.1 为什么需要RTTI
RTTI:运行时类型检查，即在运行时，识别一个对象的类型。

在Java中，所有的类型转换都是在运行时进行正确性检查的。

在编译时，由容器和Java的泛型系统来强制确保基础引用类型；在运行时，由类型转换操作来确保具体是哪一个类型的对象。

多态机制，执行什么样的代码，是由引用指向的具体对象决定的。

代码尽可能少的了解对象的具体类型，只与对象家族的一个通用表示打交道，这样代码会更容易写，读，维护。设计也更容易实现，理解和改变。所以，“多态”是面向对象编程的基本目标。


## 14.2 Class对象
`Class`对象用来创建类的所有“常规”对象。Java使用`Class`对象来执行其**RTTI**。

每个类都有一个`Class`对象。每当编写并且编译了一个新类，就会产生一个`Class`对象（它被保存在一个同名的.class文件中）。为了生成这个类的对象，JVM将使用类加载器。

类加载器实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是可信类，包括Java API类，他们通常从本地磁盘上加载。这条链中不需要添加额外的类加载器。如果有特殊需求（例如以某种特殊的方式加载类），那么你有一种方式可以挂接额外的类加载器。

所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类，使用`new`操作符创建类的新对象也会被当做类的静态成员的引用。

Java程序在它开始运行之前并非被完全加载，各个部分是在必需时才加载。这与许多传统语言不同。

类加载器首先检查这个类的`Class`对象是否已经加载。如果未加载，默认的类加载器就会根据类型查找**.class**文件。在这个类的字节码被加载时，会接受验证确保没有损坏并不包含不良Java代码。一旦这个类的`Class`对象被载入内存，它就被用来创建这个类的所有对象。

`Class.forName()`是`Class`类的一个`static`成员。`Class`对象就和其它对象一样，我们可以获取并操作它的引用。`forName()`是取得`Class`对象的引用的一种方法。它是用一个包含目标类名的`String`作为参数，返回的是一个`Class`对象的引用。对`forName`的调用是为了产生它的副作用：如果类还没有加载就加载它。  
如果`Class.forName()`找不到要加载的类，会抛出`ClassNotFoundException`。

如果想在运行时使用类型信息，必须首先获得对恰当的`Class`对象的引用。`Class.forName()`就是实现此功能的便捷途径。如果已经拥有了一个类型的对象，那就可以通过`getClass()`方法来获取`Class`引用了，这个方法是`Object`的一部分。  
`Class`包含很多有用的方法:
- `getName()`获取全类名。
- `getSimpleName()`获取类名。
- `getCanonicalName()`获取全类名。
- `isInterface()`这个类是否表示某个接口。
- `getInterfaces()`返回类所有接口Class的数组。
- `getSuperclass()`获取类的直接父类。
- `newInstance()`创建这个`Class`对象表示类的对象，但是会得到`Object`引用。另外使用`newInstance()`必须带有默认的构造器。


### 14.2.1 类字面常量
Java还提供了另一种方法生成`Class`对象的引用，即使用**类字面常量**。例如：`FancyToy.class`。这样做更简单安全，因为它在编译时就会受到检查（因此不需要至于`try`语句块中），并且它根除了对`forName`方法的调用，所以也更高效。

类字面常量可以用于普通类，接口，数组，基本数据类型。对于基本数据类型的包装器类，还有一个标准字段**TYPE**。**TYPE**是一个引用，指向对应基本数据类型的`Class`对象。

**注意:**与`Class.forName`不同的，当使用**.class**来创建`Class`对象的引用时，不会自动初始化该`Class`对象。  
为了类而做的准备工作实际包含3个步骤：
1. 加载，这是有类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个`Class`对象。
2. 链接。在链接阶段将验证字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的的其它类的所有引用。
3. 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

仅使用**.class**语法来获得对类的引用不会引发初始化。例如`Class initable = Initable.class`并不会引发初始化。

编译器常量不需要类的初始化就可以被读取。但是如果只是将一个域设置为`static final`还不足以确保这种行为。  如果一个`static`域不是`final`的，那么对它访问时，总是要求它被读取之前，要先进行链接和初始化。

### 14.2.2 泛化的Class引用
`Class`引用表示的实际上它所指向的对象的确切类型，这个类型对象就是`Class`类的一个对象。

向`Class`引用添加泛型语法的原因仅仅是为了提供编译期类型检查。当使用了确切的泛型，`newInstance`将返回该对象的确切类型。例如：
```java
Class<FancyToy> ftClass = FancyToy.class;
FancyToy fancyToy = ftClass.newInstance();
```
但是，
```java
Class<FancyToy> ftClass = FancyToy.class;
//Class<Toy> ftClass = ftClass.getSuperClass();不会通过编译，即使Toy
是FancyToy的父类，必须使用下面的声明。而且newInstance将返回Object引用。
Class<? super FancyToy> up = ftClass.getSuperClass();
Object obj = up.newInstance();
```

### 14.2.3 新的转型语法
```java
Building b = new House();
Class<House> houseType = House.class;
House h = houseType.cast(b);
```
这与普通的强制类型转换`h = (House)b;`好像做了很多额外的工作，我们一般不会使用它。