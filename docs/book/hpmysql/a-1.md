---
title: 第1章 MySQL架构与历史
---

MySQL最重要，最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理及其他系统任务和数据的存储/提取相分离。

## 1.1 MySQL逻辑架构
最上层的服务是**连接/线程处理**，这不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等。  
第二层的架构是MySQL的核心服务功能，包括查询解析，分析，优化，缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等。  
第三层包含了存储引擎。负责MySQL数据的存储和提取。每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。

### 1.1.1 连接管理与安全性
每一个连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。

### 1.1.2 优化与执行
MySQL会解析查询，创建内部解析树，对其进行优化，选择合适的索引。用户可以通过关键字来影响优化器的决策过程。

## 1.2 并发控制
两个线程同时修改一条数据可能会产生错误。

### 1.2.1 读写锁
解决这类经典问题的方法就是并发控制。共享锁和排他锁，也叫读锁和写锁。

读锁是共享的，写锁是排他的。

多个客户可以在同一时刻读取同一个资源，而互不干扰；写锁是排他的，一个写锁会阻塞其他的写锁和读锁。这是出于安全策略的考虑，防止其他用户读取正在写入的资源。

### 1.2.2 锁粒度
锁粒度级别越小，系统的并发程度就越高。因为我们只对需要修改的数据片进行精确的锁定，不会锁定额外的信息。

加锁也需要消耗资源，获得锁，检查锁是否解除，释放锁，都会增加系统开销。因此寻求一个合适的锁策略不是一个简单的问题。

锁策略就是在锁的开销和数据的安全性之间寻求平衡。大多数商业数据库都是在表上施加行级锁，并以各种复杂方式实现，以便在锁比较多的情况下保持性能。

而MySQL提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

两种最重要的锁策略：
- 表锁。最基本的锁策略，开销最小。它会锁定整张表。在对表进行写操作前，需要先获得写锁，这会阻塞其他用户的所有读写操作。
- 行级锁。最大程度的支持并发处理，也带来了最大的锁开销。

## 1.3 事务
事务的ACID。
- 原子性。（Atomicity）
- 一致性。（Consistency）
- 隔离性。（Isolation）
- 持久性。（Durability）

### 1.3.1 隔离级别
SQL 标准中定义了四种隔离级别，每一种级别都规定一个事务中所做的修改。

较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

#### READ UNCOMMITTED(未提交读)
在READ UNCOMMITTED级别中，事务中的修改语句即使没有提交，对其它事务也都可见。因此，事务可以读取未提交的数据，也被称为脏读。这个级别会导致很多问题，但是在性能上也不会比其它的级别好太多。实际中很少使用。

#### READ COMMITTED(提交读)
大多数数据的默认隔离级别都是提交读。但是MySQL不是。READ COMMITTED级别中，一个事务开始时，只能看见已提交事务所做的修改。而在这个事务执行过程中，其它事务的提交是不可见的。存在不可重复读的问题。因为执行两次相同的查询，可能会得到不一样的结果。

#### REPEATABLE READ(可重复读)  
在REPEATABLE READ级别中，在第一次读取到数据后，就对数据加锁。其它事务无法对这些锁住的数据进行修改。但是可以增加新的数据。  
REPEATABLE READ解决了脏读的问题。它保证同一个事务多次读取同样记录的结果是一致的。但是无法解决幻读的问题。  
幻读指的是，某个事务在读取某个范围数据时，另一个事务在该范围内插入了新的记录。当之前的事务再次读取时，会产生幻行。  
可重复读时MySQL的默认事务隔离级别。

#### SERIALIZABLE(可串行化)
SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。  
实际上也很少用。至于在非常需要确保数据一致性而且能够接受没有并发的情况下才考虑。

::: tip
四种隔离级别可能存在的问题：  
- READ UNCOMMITTED 存在着脏读，不可重复读，幻读。
- READ COMMITTED 存在不可重复读，幻读。
- REPEATABLE READ 存在幻读。
- SERIALIZABLE 存在加锁读。
:::

### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。  
例如，下面两个事务同时处理 StockPrice 表：  
事务1:
```sql
start transaction;
update StockPrice set close = 45.50 where stock_id = 4 and date = '2002-05-01';
update StockPrice set close = 19.80 where stock_id = 3 and date = '2002-05-02';
commit;
```
事务2：
```sql
start transaction;
update StockPrice set high = 20.12 where stock_id = 3 and date = '2002-05-02';
update StockPrice set high = 47.20 where stock_id = 4 and date = '2002-05-01';
COMMIT;
```
如果两个事务都执行了第一条 `update` 语句，更新了一行数据，同时锁定了该行数据，接着事务去尝试执行第二条 `update` 语句，但是数据却被其它事务锁定。两个事务都等待对方释放锁，同时又持有对方需要的锁，陷入死循环。

为了解决死锁问题，数据库系统实现了**死锁检测**和**死锁超时**机制。如**InnoDB存储引擎**，能检测到死锁的循环依赖，并立即返回一个错误。  
还有一种解决方式，就是当查询的时间达到锁超时时间后放弃锁请求。**InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。**

### 1.3.3 事务日志
事务日志可以帮助提高事务的效率。  
使用事务日志，存储引擎在修改表数据时，只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘。  
事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。  
事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。  
修改数据需要写两次磁盘，写事务日志和刷回磁盘。

如果数据的修改记录到事务日志但没有写回磁盘，此时系统崩溃，存储引擎在启动时能够自动恢复这部分修改的数据。

### 1.3.4 MySQL 中的事务
#### 自动提交（AUTOCOMMIT）
MySQL 默认采用自动提交模式。

如果不显式声明事务，则每个查询都被当做一个事务执行提交操作。在当前连接中，可以通过`AUTOCOMMIT`变量来启用或禁用自动提交模式：
```sql
-- 查看是否自动提交，默认为 ON
show variables like 'AUTOCOMMIT';
-- 设置是否自动提交，1或者ON为启用，0或者OFF表示禁用。
set AUTOCOMMIT = 1;
```

当禁用自动提交时，只有显式执行`commit`或者`rollback`，该事务才结束。

还有一些命令会强制提交当前活动的事务。例如`alter table`，`lock tables`等导致大量数据改变的操作。

MySQL设置隔离级别，新的隔离级别会在下次事务开始时生效。
```sql
-- 设置全局隔离级别
set transaction isolation level READ COMMITTED;
```
```sql
-- 设置当前会话隔离级别
set session transaction isolation level READ COMMITTED;
```

#### 在事务中混合使用存储引擎
MySQL服务器层不管理事务，事务由下层存储引擎实现。所以在同一事务中，使用多种存储引擎是不可靠的。

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表），在正常提交的情况下不会有什么问题。

但如果该事务需要回滚，非事务型表上的变更就无法撤销，这会导致数据库处于一种数据不一致的状态。这种情况很难修复，事务的最终结果无法确定。所以，为每张表选择合适的存储引擎非常重要。

在非事务型的表上执行事务相关操作不会出问题，只有在回滚的时候才会发出一个警告：“某些非事务型表上的变更不能被回滚。”

#### 隐式和显式锁定
InnoDB 采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行`commit`或者`rollback`的时候才会释放，并且所有的锁都是同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

另外，InnoDB也支持特定语句进行显式锁定，这些语句不属于SQL规范。即显式指明共享锁或排他锁。
- select ... lock in share mode
- select ... for update

MySQL 也支持`LOCK TABLES`和`UNLOCK TABLES`语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能代替事务处理。如果应用需要用到事务，还是应该选择事务型储存引擎。

::: warning
`LOCK TABLES`和事务之间相互影响，情况会变得非常复杂。

因此，除了事务中禁用`AUTOCOMMIT`，可以使用`LOCK TABLES`之外，其它任何使用都不要显式执行`LOCK TABLES`。
:::

## 1.4 多版本并发控制
MVCC是行级锁的一个变种，它在很多情况下避免了加锁操作，开销极低。大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。

不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的不是时间，而是系统版本号。每开启一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

### SELECT
InnoDB会根据一下两个条件检查每行记录：
a. InnoDB只查找版本早于当前事务版本的数据行（行的系统版本号小于或等于系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自己修改或插入的。
b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

### INSERT
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

### DELETE
InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

### UPDATE
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统保本和到原来的行作为行删除标识。

:::tip
保留这两个额外的系统版本号，使大多数读操作都不用加锁。性能很好，不足之处是每行记录都需要额外的存储空间。

MVCC 只在 REPEATABLE READ 和 READ COMMITED 两个隔离级别下工作。其它两个隔离级别都和MVCC不兼容，因为 READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。
:::

## 1.5 MySQL 的存储引擎
在文件系统中，MySQL将每个数据库（也可以称之为 schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的`.frm`文件保存表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows中，大小写是不敏感的；而类Unix中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。

可以使用`show table status`命令显式表的相关信息。

### 1.5.1 InnoDB 存储引擎
InnoDB是MySQL默认事务型引擎。它被设计用来处理大量短期事务，短期事务大部分情况是自动提交的，很少会回滚。InnoDB的性能和自动崩溃恢复特性，使它在非事务型存储的需求中也很流行。因此除非特别原因，都优先考虑InnoDB引擎。

#### InnoDB 概览
InnoDB的数据储存在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。

InnoDB采用MVCC来支持高并发，并且直接实现了四个标准的隔离级别。默认级别是REPEATABLE READ(可重复读)，并且通过**间隙锁策略**防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB表是基于聚簇索引建立的。InnoDB的索引结果和MySQL的其它存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（非主键索引）必须包含主键列，所以如果主键列很大，其它的所有索引都会很大。因此，若表上索引较多，主键应尽可能的小。InnoDB的存储格式是平台独立的。

InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。

### 1.5.2 MyISAM 存储引擎
在MySQL 5.1 及之前的版本，MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引，压缩，空间函数（GIS）等，但MyISAM不支持事务和行级锁，崩溃后无法安全恢复。对于只读的数据，或者表比较小，可以忍受修复操作，则可以依然继续使用MyISAM（但请不要默认使用MyISAM,而应当默认使用InnoDB）。

#### 存储
MyISAM 会将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为扩展名。MyISAM表可以包含动态或者静态行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。

#### MyISAM 特性
MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表读取查询的时候，也可以往表中插入新的记录。

#### MyISAM 性能
MyISAM最典型的性能问题还是表锁的问题。如果你发现所有的查询都长期处于“Locked”状态，那么毫无疑问表锁就是罪魁祸首。

### 1.5.3 MySQL 内建的其他存储引擎
- Archive 引擎
- Blackhole 引擎
- CSV 引擎
- Federated 引擎
- Memory 引擎
- Merge 引擎
- NDB 集群引擎

### 1.5.4 第三方存储引擎
- OLTP 类引擎
- 面向列的存储引擎
- 社区存储引擎

### 1.5.5 选择合适的引擎
InnoDB 优先选择。
事务支持，InnoDB。  
不需要事务支持，主要`select`和`insert`操作，MyISAM。
在线热备份，InnoDB。
崩溃恢复，InnoDB。

除非万不得已，不要混用多种存储引擎，否则可能带来一系列的问题，以及一些潜在的bug和边界问题。

#### 日志型应用
如果只插入日志，很少对日志进行分析。那么 MyISAM 或者 Archive 存储引擎就比较合适，因为它们开销低，而且插入速度非常快。

但是如果要对插入的日志做分析报表。生成报表的 SQL 很有可能会导致插入效率明显降低。

一种解决方法，是利用 MySQL 内置的复制方案将数据复制一份到备库，在备库上执行比较消耗时间和CPU的查询，读写分离。  
另一种解决方法，在日志记录表的名字中包含年和月的信息，比如 web_logs_2012-01 或 web_logs_2012_jan。这样可以在已经没有插入操作的历史表上做频繁的查询操作，而不会干扰到最新的当前表上的插入操作。

#### 只读或大部分情况下只读的表
类似于数据字典表这种情况，读多写少。如果不介意 MyISAM 的崩溃恢复问题，选用 MyISAM 引擎是合适的。MyISAM 只将数据写到内存中，然后等待操作系统定期将数据刷出到磁盘上。

不要轻易相信“MyISAM比InnoDB快”之类的经验之谈。

#### 订单处理
如果涉及订单处理，那么支持事务就是必要选项。InnoDB是订单处理类应用的最佳选择。

### 1.5.6 转换表的引擎

#### alter table
可以使用`alter table`语句将表更改存储引擎。
```sql
alter table mytable engine = InnoDB;
```
MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁，而且需要执行很长时间。因此，在繁忙的表上执行此操作要特别注意。

如果转换表的存储引擎，将会失去和原引擎相关的所有特性。例如，如果将一张InnoDB表转换为 MyISAM ，然后再转换回 InnoDB，原 InnoDB 表上所有的外键将丢失。

#### 导出与导入
因此我们可以用另外一种方法来代替上述。即使用 mysqldump 工具导出到文件，然后修改`create table`语句的存储引擎选项，同时注意修改表名。

#### 创建与查询
第三种转换的技术综合了第一种方法的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用`insert`和`select`语法来导数据：
```sql
create table innodb_table like myisam_table;
alter table innodb_table engine = InnoDB;
insert into innodb_table select * from myisam_table;
```
如有必要，可在执行过程中对原表加锁，以确保新表和原表的数据一致。