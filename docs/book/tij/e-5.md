---
title: 第5章 初始化与清理
---

> 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

## 5.1 用构造器确保初始化
构造器采用与类相同的名称，没有任何返回值。

创建对象时，将会为对象分配存储空间，并调用相应的构造器。不接受任何参数的构造器叫做**默认构造器（无参构造器）**。如果创建了自己的构造器，编译器将不会允许其它方式创建对象。

## 5.2 方法重载
### 5.2.1 区分重载方法
每个重载的方法都必须有一个独一无二的参数列表。

根据方法的返回值来区分重载方法是行不通的。因为有些时候你可能会调用方法而忽略返回值。

## 5.3 默认构造器
如果类中没有构造器，编译器会自动创建一个默认构造器；如果你创建了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器

## 5.4 this 关键字
`this`关键字只能在方法内部使用，表示对“调用方法那个对象的引用”。

### 5.4.1 在构造器中调用构造器
可以使用`this`在构造器中调用构造器，但最多只能调用一个，且必须将构造器调用置于起始处。

除构造器外，编译器禁止在任何其它方法中调用构造器。

### 5.4.2 static 的含义
`static`方法内部不能调用**非静态方法**，反过来可以。

使用`static`方法时不存在`this`。

可以在没有创建任何对象的前提下，通过类本身来调用`static`方法。


## 5.5 清理：终结处理和垃圾回收
垃圾回收负责回收无用对象占据的内存资源，只知道释放经由`new`分配的内存。因此：

1. 对象可能不被垃圾回收。
2. 垃圾回收不等于析构。
3. 垃圾回收只与内存有关。

而通过其它方式为对象分配的内存却无法被垃圾回收器回收。

这种其它方式一般是可能在分配内存时采用了类似C语言中的做法，这种情况主要发生在使用本地方法下。本地方法是在Java中调用非Java代码的方式。在这些非Java代码中，也许会调用C的`malloc()`函数系列来分配存储空间，除非调用`free()`函数，否则存储空间无法释放。因此，需要在`finalize()`中用本地方法调用它。

这就是`finalize()`一般的使用场景，当然一般是用不到的。

### 5.5.2 你必须实施清理
垃圾回收器不能完全代替析构函数，而且绝对不能直接调用`finalize()`。如果希望进行释放存储空间之外的清理工作，还是得明确调用某个Java方法。这就等同于析构函数了，但是没有它方便。

记住，无论是垃圾回收还是终结，都不保证一定会发生。如果JVM并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

### 5.5.3 终结条件
`finalize()`只能存在于程序员很难用到的一些晦涩用法。

例如：可以用它来判断对象是否达到可以被回收的状态。

`System.gc()`用于强制进行终结动作。

### 5.5.4 垃圾回收器如何工作
当创建了足够多的对象，内存资源将被耗尽时，垃圾回收器将会启动。当垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就可以很容易移动到传送带的开始处，通过垃圾回收器对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。

- **停止-复制**模式。暂停程序运行，将所有存活的对象从一个堆复制到另一个堆。问题是，当没有什么垃圾产生时，也会将所有内存复制一遍。为避免这种情况，一些JVM会切换到**标记-清扫**模式。
- **标记-清扫**模式。Sun公司早期版本的JVM使用这种做法。从堆栈和静态存储区出发，遍历所有的引用，进而找到所有存活的对象，给每个对象设一个标记。当全部标记工作完成时，开始清理，没有被标记的对象将被释放，不会发生任何复制动作。但是剩下的堆空间是不连续的。
- **分代**模式。垃圾回收器回收时往废弃的块里拷贝对象。每个块都用相应的**代数**来记录它是否存活。如果在某处被引用，**代数**增加。垃圾回收器定期清理时，大型对象不会被复制（代数增加），内含小型对象的那些快则被复制并整理。当对象稳定，垃圾回收器效率降低时，就会切换到**标记-清扫**模式。

这就是“自适应的，分代的，停止-复制，标记-清扫”式垃圾回收器。

## 5.6 成员初始化
类中的成员变量是基本类型，它们就会有一个默认初始值。对象引用默认为null，在实例化之前不能调用它。

局部变量必须要手动赋初值。

## 5.7 构造器初始化
自动初始化在构造器被调用之前发生。

### 5.7.1 初始化顺序
成员变量会首先初始化，即使变量散落在类的各处。

### 5.7.2 静态数据的初始化
无论创建多少个对象，静态数据都只占用一份存储区域。`static`关键字不能应用于局部变量，只能作用于域。

当第一次加载类时，类中的静态成员首先初始化（只会调用一次，当第二次创建类时，静态成员不会被再次初始化。）静态成员初始化后，非静态成员会初始化。然后执行构造器。

静态初始化只会在`Class`对象首次加载时进行一次。

### 5.7.3 显式的静态初始化
`static`静态代码块，初始化动作如同`static`成员变量，也只执行一次。

### 5.7.4 非静态实例初始化
非静态代码块，每次调用构造器时，都会在构造器之前执行。

## 5.8 数组初始化
C，C++ 中习惯使用`int a[];`，Java 中习惯使用`int[] a`来定义数组。

可以使用`{}`来对数组进行初始化，例如:
```java
int[] a = {1,2,3,4,5};
```
如果不确定初始化值，也可以使用`new`来创建，例如：
```java
int[] a = new int[5];
```
它具有默认初始化值：0

如果创建了非基本类型的数据，那么它的默认值为`null`，例如：
```java
Integer[] a = new Integer[5];
```
::: warning
如果忘记创建`Integer`对象，那么在访问时就会**空指针异常**。
:::

### 5.8.1 可变参数列表
有了可变参数，就不用再显式的编写数组语法，当你指定参数时，编译器会自动填充数组。
你获取的仍然是一个数组。例如：
```java
static void printArray(Object... args){
     for(Object obj : args){
         System.out.print(obj+" ");
     }
     System.out.println();
}
```
可以将 0 个参数传递给可变参数。

可变参数使重载变得复杂，因为当传入参数为 0 个参数时，编译器并不知道你想要调用哪个。

## 5.9 枚举类型
在你创建`enum`时，编辑器会自动添加一些有用的特性。例如：它会自动创建`toString()`方法，以便你可以方便显式某个`enum`实例的名字。

编译器还会创建`ordinal()`方法，用来表示某个特定`enum`常量的声明顺序.

以及`static values()`方法，用来按照`enum`常量的声明顺序，产生这些常量值构成的数组。例如：
```java
public enum Spiciness{
    NOT, MILD, MEDIUM, HOT, FLAMING
}
public class EnumOrder{
    public static void main(String[] args){
        for(Spiciness s : Spiciness.values()){
            System.out.println(s + ", ordinal " + s.ordinal());
        }
    }
}
/* Output:
NOT, ordinal 0
MILD, ordinal 1
MEDIUM, ordinal 2
HOT, ordinal 3
FLAMING, ordinal 4
*/
```
通常用法：
```java
public enum  EnumTest {
    AUTHOR1("小明"),AUTHOR2("小白");

    private String value;
    EnumTest(String value) {
        this.value = value;
    }

    public String getValue(){
        return value;
    }
}
```
`enum`可以在`switch`语句内使用，它们是一种绝佳的组合。


