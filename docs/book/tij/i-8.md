---
title: 第8章 多态
---

> 抽象，继承，多态是面向对象语言的三种基本特征

多态也成为动态绑定，后期绑定或运行时绑定。

## 8.1 再论向上转型
### 8.1.1 忘记对象类型
当在参数中使用基类作为参数，编写的代码只是与基类打交道。不必为每个导出类都写一个方法。

## 8.2 多态的实现
方法接收基类引用，如何才能知道它具体是哪一个子类呢？

### 8.2.1 绑定：前期绑定和后期绑定
将一个方法调用同一个方法主体关联起来被称作**绑定**。

若在程序执行前进行绑定，叫做**前期绑定**。它是面向过程语言默认的绑定方式。C例如，C语言中只有一种方法调用，就是**前期绑定**。

Java中实现多态的方法就是**后期绑定**，也叫做**动态绑定**或**运行时绑定**。

::: tip
Java中除了`static`方法和`final`方法(`private`方法属于`final`方法)之外，其它所有的方法都是**后期绑定**。

将方法声明为`final`就可以关闭**动态绑定**，这虽然看起来提高了运行时性能，但是实际整体并没有什么改观。所以，最好根据设计来决定是否使用`final`，而不是想提高性能。
:::

### 8.2.3 多态的可扩展性
由于存在**多态**机制，我们就可根据自己的需求对系统添加任意多的新类型，而不必改动操作基类接口的方法。

**多态**是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。

### 8.2.4 无法覆盖 `private` 方法
`private`方法被自动认为是`final`方法，所以它无法被覆盖。

只有非`private`方法才可以被覆盖，`final`方法无法覆盖。

::: tip
当基类中存在`private`方法时，子类试图去覆盖它时。编译器会将这两个方法当成毫无关联的方法，无法覆盖。因为基类中的`private`方法对于子类是隐藏的。

当在基类中存在非`private`的`final`方法时，它不是私有的，会继承给子类。但是由于它是`final`的，所以试图去覆盖它时，编译器就无法通过。
:::


### 8.2.5 `static` 方法不具有多态性
当基类中存在非`private`域时，子类中存在相同的域，编译器会为这两个域分配不同的存储空间。

但是，通常我们会将所有的域设置为`private`。

::: tip
例如，当基类中存在`public int a = 0;`，子类中也存在`public int a = 1;`时，实际上会存在`this.a`和`super.a`两个域，它们占有不同的存储空间，用`this`和`super`来区分，当然若子类不存在`public int a = 1`，那么当使用 `a` 时，会自动使用父类的`a`。
:::

`static`方法也不具有多态性，引用是什么类型，它就会调用什么类型的方法。因为这个方法运行前实际已经存在。静态方法是与类，而并非是对象相关联的。


## 8.3 构造器和多态

### 8.3.1 构造器的调用顺序
基类的构造器总是在导出类的构造过程中被调用，并且按照继承层次主键向上链接，以使每个基类的构造器都能得到调用。

::: tip
这是因为导出类只能访问它自己的成员，不能访问基类的成员，因为基类成员通常是`private`类型。只有基类的构造器才能对自己的元素初始化。因此必须令所有构造器都得到调用，否则不能正确构造完整对象。
:::

导出类的构造器中，如果没有明确指定调用某个基类构造器，它就会默认调用默认构造器。如果不存在默认构造器，编译器就会报错。

### 8.3.2 继承和清理
清理动作一般是由垃圾回收器完成。如果我们需要完成其它的清理，那么清理顺序需要与初始化顺序相反。

例如，首先对导出类进行清理，然后才是基类。

因为，导出类的清理，可能会调用基类中的某些方法。

### 8.3.3 构造器内部的多态方法的行为
当基类构造器中调用了被覆盖的方法时，会使用被覆盖的方法，而不是当前类中的原有方法。

这可能会导致结果跟预期的不一致，因为基类构造器在执行过程中，子类的成员变量还没有初始化（即使你手动初始化），默认分配给对象的存储空间时二进制的零。

因此，避免在构造器中调用非`final`方法，这些方法不能被覆盖，也就不会出现上述预期之外的结果。

## 8.4 协变返回类型
它表示，在导出类中的被覆盖方法可以返回基类方法的返回方法的某种导出类型。

简言之，子类覆盖基类的方法，其中子类的返回类型可以是父类返回类型的子类。

## 8.5 用继承进行设计
### 8.5.1 纯继承与扩展
当子类只覆盖了基类中的接口，并没有新增额外的方法，称之为 **is-a**。

当子类添加了额外的方法，可以称之为 **is-like-a** 。

添加了新方法后，一旦向上转型，就不能调用那些新方法。

### 8.5.2 运行时类型
**向上转型**会丢失具体的类型信息，但它是安全的，因为基类不会有大于导出类的接口。

**向下转型**是不安全的。运行时会对其进行检查。如果不是，就会抛出`ClassCastException`异常。这种运行期间对类型进行检查的行为称为“运行时类型识别（RTTI）”。

## 8.6 总结
**多态**意味着“不同的形式”。我们持有从基类继承而来的相同接口，以及使用该接口的不同形式，不同版本的**动态绑定**方法。

**多态**是一种不能单独来看待的特性，它只能作为类关系中的一部分，与其它特性协同工作。

