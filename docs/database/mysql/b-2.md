---
autoGroup-1: 高性能 MySQL
title: 第1章 MySQL架构与历史
---

MySQL最重要，最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理及其他系统任务和数据的存储/提取相分离。

## 1.1 MySQL逻辑架构
最上层的服务是**连接/线程处理**，这不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等。  
第二层的架构是MySQL的核心服务功能，包括查询解析，分析，优化，缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等。  
第三层包含了存储引擎。负责MySQL数据的存储和提取。每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。

### 1.1.1 连接管理与安全性
每一个连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。

### 1.1.2 优化与执行
MySQL会解析查询，创建内部解析树，对其进行优化，选择合适的索引。用户可以通过关键字来影响优化器的决策过程。

## 1.2 并发控制
两个线程同时修改一条数据可能会产生错误。

### 1.2.1 读写锁
解决这类经典问题的方法就是并发控制。共享锁和排他锁，也叫读锁和写锁。

读锁是共享的，写锁是排他的。

多个客户可以在同一时刻读取同一个资源，而互不干扰；写锁是排他的，一个写锁会阻塞其他的写锁和读锁。这是出于安全策略的考虑，防止其他用户读取正在写入的资源。

### 1.2.2 锁粒度
锁粒度级别越小，系统的并发程度就越高。因为我们只对需要修改的数据片进行精确的锁定，不会锁定额外的信息。

加锁也需要消耗资源，获得锁，检查锁是否解除，释放锁，都会增加系统开销。因此寻求一个合适的锁策略不是一个简单的问题。

锁策略就是在锁的开销和数据的安全性之间寻求平衡。大多数商业数据库都是在表上施加行级锁，并以各种复杂方式实现，以便在锁比较多的情况下保持性能。

而MySQL提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

两种最重要的锁策略：
- 表锁。最基本的锁策略，开销最小。它会锁定整张表。在对表进行写操作前，需要先获得写锁，这会阻塞其他用户的所有读写操作。
- 行级锁。最大程度的支持并发处理，也带来了最大的锁开销。

## 1.3 事务
事务的ACID。
- 原子性。（Atomicity）
- 一致性。（Consistency）
- 隔离性。（Isolation）
- 持久性。（Durability）

### 1.3.1 隔离级别
SQL 标准中定义了四种隔离级别，每一种级别都规定一个事务中所做的修改。

较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

#### READ UNCOMMITTED(未提交读)
在READ UNCOMMITTED级别中，事务中的修改语句即使没有提交，对其它事务也都可见。因此，事务可以读取未提交的数据，也被称为脏读。这个级别会导致很多问题，但是在性能上也不会比其它的级别好太多。实际中很少使用。

#### READ COMMITTED(提交读)
大多数数据的默认隔离级别都是提交读。但是MySQL不是。READ COMMITTED级别中，一个事务开始时，只能看见已提交事务所做的修改。而在这个事务执行过程中，其它事务的提交是不可见的。存在不可重复读的问题。因为执行两次相同的查询，可能会得到不一样的结果。

#### REPEATABLE READ(可重复读)  
在REPEATABLE READ级别中，在第一次读取到数据后，就对数据加锁。其它事务无法对这些锁住的数据进行修改。但是可以增加新的数据。  
REPEATABLE READ解决了脏读的问题。它保证同一个事务多次读取同样记录的结果是一致的。但是无法解决幻读的问题。  
幻读指的是，某个事务在读取某个范围数据时，另一个事务在该范围内插入了新的记录。当之前的事务再次读取时，会产生幻行。  
可重复读时MySQL的默认事务隔离级别。

#### SERIALIZABLE(可串行化)
SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。  
实际上也很少用。至于在非常需要确保数据一致性而且能够接受没有并发的情况下才考虑。

::: tip
四种隔离级别可能存在的问题：  
- READ UNCOMMITTED 存在着脏读，不可重复读，幻读。
- READ COMMITTED 存在不可重复读，幻读。
- REPEATABLE READ 存在幻读。
- SERIALIZABLE 存在加锁读。
:::

### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。  
例如，下面两个事务同时处理 StockPrice 表：  
事务1:
```sql
start transaction;
update StockPrice set close = 45.50 where stock_id = 4 and date = '2002-05-01';
update StockPrice set close = 19.80 where stock_id = 3 and date = '2002-05-02';
commit;
```
事务2：
```sql
start transaction;
update StockPrice set high = 20.12 where stock_id = 3 and date = '2002-05-02';
update StockPrice set high = 47.20 where stock_id = 4 and date = '2002-05-01';
COMMIT;
```
如果两个事务都执行了第一条 `update` 语句，更新了一行数据，同时锁定了该行数据，接着事务去尝试执行第二条 `update` 语句，但是数据却被其它事务锁定。两个事务都等待对方释放锁，同时又持有对方需要的锁，陷入死循环。

为了解决死锁问题，数据库系统实现了**死锁检测**和**死锁超时**机制。如**InnoDB存储引擎**，能检测到死锁的循环依赖，并立即返回一个错误。  
还有一种解决方式，就是当查询的时间达到锁超时时间后放弃锁请求。**InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。**

### 1.3.3 事务日志
事务日志可以帮助提高事务的效率。  
使用事务日志，存储引擎在修改表数据时，只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘。  
事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。  
事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。  
修改数据需要写两次磁盘，写事务日志和刷回磁盘。

如果数据的修改记录到事务日志但没有写回磁盘，此时系统崩溃，存储引擎在启动时能够自动恢复这部分修改的数据。

### 1.3.4 MySQL 中的事务
#### 自动提交（AUTOCOMMIT）
MySQL 默认采用自动提交模式。

如果不显式声明事务，则每个查询都被当做一个事务执行提交操作。在当前连接中，可以通过`AUTOCOMMIT`变量来启用或禁用自动提交模式：
```sql
-- 查看是否自动提交，默认为 ON
show variables like 'AUTOCOMMIT';
-- 设置是否自动提交，1或者ON为启用，0或者OFF表示禁用。
set AUTOCOMMIT = 1;
```

当禁用自动提交时，只有显式执行`commit`或者`rollback`，该事务才结束。

还有一些命令会强制提交当前活动的事务。例如`alter table`，`lock tables`等导致大量数据改变的操作。

MySQL设置隔离级别，新的隔离级别会在下次事务开始时生效。
```sql
-- 设置全局隔离级别
set transaction isolation level READ COMMITTED;
```
```sql
-- 设置当前会话隔离级别
set session transaction isolation level READ COMMITTED;
```

#### 在事务中混合使用存储引擎
MySQL服务器层不管理事务，事务由下层存储引擎实现。所以在同一事务中，使用多种存储引擎是不可靠的。

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表），在正常提交的情况下不会有什么问题。

但如果该事务需要回滚，非事务型表上的变更就无法撤销，这会导致数据库处于一种数据不一致的状态。这种情况很难修复，事务的最终结果无法确定。所以，为每张表选择合适的存储引擎非常重要。

在非事务型的表上执行事务相关操作不会出问题，只有在回滚的时候才会发出一个警告：“某些非事务型表上的变更不能被回滚。”

#### 隐式和显式锁定
InnoDB 采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行`commit`或者`rollback`的时候才会释放，并且所有的锁都是同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

另外，InnoDB也支持特定语句进行显式锁定，这些语句不属于SQL规范。即显式指明共享锁或排他锁。
- select ... lock in share mode
- select ... for update

MySQL 也支持`LOCK TABLES`和`UNLOCK TABLES`语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能代替事务处理。如果应用需要用到事务，还是应该选择事务型储存引擎。

::: warning
`LOCK TABLES`和事务之间相互影响，情况会变得非常复杂。

因此，除了事务中禁用`AUTOCOMMIT`，可以使用`LOCK TABLES`之外，其它任何使用都不要显式执行`LOCK TABLES`。
:::

## 1.4 多版本并发控制
MVCC是行级锁的一个变种，它在很多情况下避免了加锁操作，开销极低。大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。

不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的不是时间，而是系统版本号。每开启一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

### SELECT
InnoDB会根据一下两个条件检查每行记录：
a. InnoDB只查找版本早于当前事务版本的数据行（行的系统版本号小于或等于系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自己修改或插入的。
b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

### INSERT
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

### DELETE
InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

### UPDATE
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统保本和到原来的行作为行删除标识。

:::tip
保留这两个额外的系统版本号，使大多数读操作都不用加锁。性能很好，不足之处是每行记录都需要额外的存储空间。

MVCC 只在 REPEATABLE READ 和 READ COMMITED 两个隔离级别下工作。其它两个隔离级别都和MVCC不兼容，因为 READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。
:::

## 1.5 MySQL 的存储引擎
在文件系统中，MySQL将每个数据库（也可以称之为 schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的`.frm`文件保存表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows中，大小写是不敏感的；而类Unix中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。

可以使用`show table status`命令显式表的相关信息。

### 1.5.1 InnoDB 存储引擎
InnoDB是MySQL默认事务型引擎。它被设计用来处理大量短期事务，短期事务大部分情况是自动提交的，很少会回滚。InnoDB的性能和自动崩溃恢复特性，使它在非事务型存储的需求中也很流行。因此除非特别原因，都优先考虑InnoDB引擎。

#### InnoDB 概览
InnoDB的数据储存在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。

InnoDB采用MVCC来支持高并发，并且直接实现了四个标准的隔离级别。默认级别是REPEATABLE READ(可重复读)，并且通过**间隙锁策略**防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB表是基于聚簇索引建立的。InnoDB的索引结果和MySQL的其它存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（非主键索引）必须包含主键列，所以如果主键列很大，其它的所有索引都会很大。因此，若表上索引较多，主键应尽可能的小。InnoDB的存储格式是平台独立的。

InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。